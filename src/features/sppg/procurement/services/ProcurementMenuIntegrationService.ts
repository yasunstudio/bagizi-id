/**
 * @fileoverview Procurement Menu Integration Service
 * @version Next.js 15.5.4 / Prisma 6.17.1
 * @author Bagizi-ID Development Team
 * @see {@link /docs/copilot-instructions.md} Development Guidelines
 * 
 * BUSINESS LOGIC:
 * - Auto-generate procurement plans from menu plans
 * - Calculate required ingredients based on menu recipes and target recipients
 * - Estimate budget based on current inventory prices
 * - Validate menu coverage by procurement items
 * - Provide smart procurement suggestions
 */

import { db } from '@/lib/prisma'
import { InventoryCategory } from '@prisma/client'

/**
 * Interface for ingredient requirements from menu analysis
 */
interface IngredientRequirement {
  inventoryItemId: string
  itemName: string
  itemCode: string | null
  category: InventoryCategory
  brand: string | null
  requiredQuantity: number
  unit: string
  estimatedPrice: number
  totalCost: number
  usedInMenus: Array<{
    menuId: string
    menuName: string
    portionSize: number
    plannedPortions: number
  }>
}

/**
 * Interface for auto-generated procurement plan data
 */
interface AutoGeneratedProcurementData {
  ingredients: IngredientRequirement[]
  totalBudget: number
  budgetBreakdown: {
    protein: number
    carbs: number
    vegetables: number
    fruits: number
    other: number
  }
  menuCoverage: {
    totalMenus: number
    coveredMenus: number
    coveragePercentage: number
  }
  warnings: string[]
}

/**
 * Procurement Menu Integration Service
 * Handles integration between menu planning and procurement
 */
export class ProcurementMenuIntegrationService {
  /**
   * Calculate required ingredients from menu plan
   * Aggregates all menu ingredients with quantities scaled by target recipients
   * 
   * @param menuPlanId - Menu plan ID
   * @param sppgId - SPPG ID for multi-tenant isolation
   * @returns Ingredient requirements with pricing
   */
  async calculateRequiredIngredientsFromMenuPlan(
    menuPlanId: string,
    sppgId: string
  ): Promise<IngredientRequirement[]> {
    // Fetch menu plan with all menus and ingredients
    const menuPlan = await db.menuPlan.findUnique({
      where: {
        id: menuPlanId,
        sppgId, // ✅ Multi-tenant isolation
      },
      include: {
        assignments: {
          include: {
            menu: {
              include: {
                ingredients: {
                  include: {
                    inventoryItem: true,
                  },
                },
              },
            },
          },
        },
      },
    })

    if (!menuPlan) {
      throw new Error('Menu plan not found')
    }

    // Aggregate ingredients across all menus
    const ingredientMap = new Map<string, IngredientRequirement>()

    for (const assignment of menuPlan.assignments) {
      const menu = assignment.menu
      const plannedPortions = assignment.plannedPortions || 0

      for (const ingredient of menu.ingredients) {
        const item = ingredient.inventoryItem
        const key = item.id

        // Calculate quantity for this menu
        const quantityPerPortion = ingredient.quantity // Already per portion from recipe
        const totalQuantity = quantityPerPortion * plannedPortions

        if (ingredientMap.has(key)) {
          // Add to existing ingredient
          const existing = ingredientMap.get(key)!
          existing.requiredQuantity += totalQuantity
          existing.totalCost = existing.requiredQuantity * existing.estimatedPrice
          existing.usedInMenus.push({
            menuId: menu.id,
            menuName: menu.menuName,
            portionSize: menu.servingSize,
            plannedPortions,
          })
        } else {
          // Create new ingredient requirement
          const estimatedPrice = item.costPerUnit || item.lastPrice || item.averagePrice || 0
          ingredientMap.set(key, {
            inventoryItemId: item.id,
            itemName: item.itemName,
            itemCode: item.itemCode,
            category: item.category,
            brand: item.brand,
            requiredQuantity: totalQuantity,
            unit: item.unit,
            estimatedPrice,
            totalCost: totalQuantity * estimatedPrice,
            usedInMenus: [
              {
                menuId: menu.id,
                menuName: menu.menuName,
                portionSize: menu.servingSize,
                plannedPortions,
              },
            ],
          })
        }
      }
    }

    return Array.from(ingredientMap.values())
  }

  /**
   * Calculate total budget with category breakdown
   * 
   * @param ingredients - List of ingredient requirements
   * @returns Total budget and category breakdown
   */
  calculateTotalBudget(ingredients: IngredientRequirement[]): {
    totalBudget: number
    budgetBreakdown: AutoGeneratedProcurementData['budgetBreakdown']
  } {
    const breakdown = {
      protein: 0,
      carbs: 0,
      vegetables: 0,
      fruits: 0,
      other: 0,
    }

    let totalBudget = 0

    for (const ingredient of ingredients) {
      totalBudget += ingredient.totalCost

      // Categorize by inventory category
      switch (ingredient.category) {
        case 'PROTEIN':
          breakdown.protein += ingredient.totalCost
          break
        case 'KARBOHIDRAT':
          breakdown.carbs += ingredient.totalCost
          break
        case 'SAYURAN':
          breakdown.vegetables += ingredient.totalCost
          break
        case 'BUAH':
          breakdown.fruits += ingredient.totalCost
          break
        default:
          breakdown.other += ingredient.totalCost
      }
    }

    return { totalBudget, budgetBreakdown: breakdown }
  }

  /**
   * Generate auto procurement plan from menu plan
   * Main function that orchestrates the generation process
   * 
   * @param menuPlanId - Menu plan ID
   * @param sppgId - SPPG ID for multi-tenant isolation
   * @param options - Additional options for generation
   * @returns Complete auto-generated procurement data
   */
  async generateProcurementPlanFromMenu(
    menuPlanId: string,
    sppgId: string,
    options?: {
      emergencyBuffer?: number // Percentage buffer (e.g., 10 = 10%)
      preferredSuppliers?: boolean // Use preferred suppliers from inventory
    }
  ): Promise<AutoGeneratedProcurementData> {
    // 1. Calculate required ingredients
    const ingredients = await this.calculateRequiredIngredientsFromMenuPlan(menuPlanId, sppgId)

    // 2. Apply emergency buffer if specified
    const bufferMultiplier = 1 + ((options?.emergencyBuffer || 0) / 100)
    const adjustedIngredients = ingredients.map((ing) => ({
      ...ing,
      requiredQuantity: ing.requiredQuantity * bufferMultiplier,
      totalCost: ing.totalCost * bufferMultiplier,
    }))

    // 3. Calculate budget
    const { totalBudget, budgetBreakdown } = this.calculateTotalBudget(adjustedIngredients)

    // 4. Calculate menu coverage
    const menuPlan = await db.menuPlan.findUnique({
      where: { id: menuPlanId, sppgId },
      include: {
        assignments: {
          include: { menu: true },
        },
      },
    })

    const totalMenus = menuPlan?.assignments.length || 0
    const uniqueMenus = new Set(adjustedIngredients.flatMap((ing) => ing.usedInMenus.map((m) => m.menuId)))
    const coveredMenus = uniqueMenus.size

    // 5. Generate warnings
    const warnings: string[] = []
    
    // Check for items without pricing
    const itemsWithoutPrice = adjustedIngredients.filter((ing) => ing.estimatedPrice === 0)
    if (itemsWithoutPrice.length > 0) {
      warnings.push(
        `${itemsWithoutPrice.length} item(s) tidak memiliki harga. Silakan update harga inventory terlebih dahulu.`
      )
    }

    // Check for low stock items
    const lowStockItems = await this.checkLowStockItems(adjustedIngredients, sppgId)
    if (lowStockItems.length > 0) {
      warnings.push(
        `${lowStockItems.length} item(s) memiliki stok rendah atau tidak mencukupi.`
      )
    }

    // Check menu coverage
    if (coveredMenus < totalMenus) {
      warnings.push(
        `Hanya ${coveredMenus} dari ${totalMenus} menu yang memiliki ingredient data lengkap.`
      )
    }

    return {
      ingredients: adjustedIngredients,
      totalBudget,
      budgetBreakdown,
      menuCoverage: {
        totalMenus,
        coveredMenus,
        coveragePercentage: totalMenus > 0 ? (coveredMenus / totalMenus) * 100 : 0,
      },
      warnings,
    }
  }

  /**
   * Validate procurement coverage for menu plan
   * Check if current procurement items cover menu requirements
   * 
   * @param menuPlanId - Menu plan ID
   * @param procurementPlanId - Procurement plan ID
   * @param sppgId - SPPG ID for multi-tenant isolation
   * @returns Coverage analysis with gaps
   */
  async validateProcurementCoverage(
    menuPlanId: string,
    procurementPlanId: string,
    sppgId: string
  ): Promise<{
    isCovered: boolean
    coveragePercentage: number
    gaps: Array<{
      itemName: string
      required: number
      procured: number
      shortfall: number
      unit: string
    }>
    surplus: Array<{
      itemName: string
      required: number
      procured: number
      excess: number
      unit: string
    }>
  }> {
    // Get required ingredients from menu
    const required = await this.calculateRequiredIngredientsFromMenuPlan(menuPlanId, sppgId)

    // Get procured items
    const procurements = await db.procurement.findMany({
      where: {
        planId: procurementPlanId,
        sppgId, // ✅ Multi-tenant isolation
      },
      include: {
        items: true,
      },
    })

    // Aggregate procured quantities
    const procuredMap = new Map<string, number>()
    for (const procurement of procurements) {
      for (const item of procurement.items) {
        if (item.inventoryItemId) {
          const current = procuredMap.get(item.inventoryItemId) || 0
          procuredMap.set(item.inventoryItemId, current + (item.receivedQuantity || item.orderedQuantity))
        }
      }
    }

    // Compare and identify gaps/surplus
    const gaps: Array<{ itemName: string; required: number; procured: number; shortfall: number; unit: string }> = []
    const surplus: Array<{ itemName: string; required: number; procured: number; excess: number; unit: string }> = []

    let totalRequired = 0
    let totalCovered = 0

    for (const req of required) {
      const procured = procuredMap.get(req.inventoryItemId) || 0
      totalRequired += req.requiredQuantity

      if (procured < req.requiredQuantity) {
        // Gap
        gaps.push({
          itemName: req.itemName,
          required: req.requiredQuantity,
          procured,
          shortfall: req.requiredQuantity - procured,
          unit: req.unit,
        })
        totalCovered += procured
      } else {
        // Covered or surplus
        totalCovered += req.requiredQuantity
        if (procured > req.requiredQuantity) {
          surplus.push({
            itemName: req.itemName,
            required: req.requiredQuantity,
            procured,
            excess: procured - req.requiredQuantity,
            unit: req.unit,
          })
        }
      }
    }

    const coveragePercentage = totalRequired > 0 ? (totalCovered / totalRequired) * 100 : 0

    return {
      isCovered: gaps.length === 0,
      coveragePercentage,
      gaps,
      surplus,
    }
  }

  /**
   * Check for low stock items
   * Private helper to identify items that need urgent procurement
   * 
   * @param ingredients - List of ingredient requirements
   * @param sppgId - SPPG ID for multi-tenant isolation
   * @returns List of low stock item names
   */
  private async checkLowStockItems(
    ingredients: IngredientRequirement[],
    sppgId: string
  ): Promise<string[]> {
    const itemIds = ingredients.map((ing) => ing.inventoryItemId)

    const items = await db.inventoryItem.findMany({
      where: {
        id: { in: itemIds },
        sppgId, // ✅ Multi-tenant isolation
      },
      select: {
        id: true,
        itemName: true,
        currentStock: true,
        minStock: true,
      },
    })

    const lowStockItems: string[] = []

    for (const item of items) {
      const required = ingredients.find((ing) => ing.inventoryItemId === item.id)?.requiredQuantity || 0
      const available = item.currentStock

      // Check if current stock + required amount exceeds available
      if (available < required || item.currentStock < item.minStock) {
        lowStockItems.push(item.itemName)
      }
    }

    return lowStockItems
  }

  /**
   * Get procurement suggestions for menu plan
   * Provides smart suggestions based on historical data and preferences
   * 
   * @param menuPlanId - Menu plan ID
   * @param sppgId - SPPG ID for multi-tenant isolation
   * @returns Procurement suggestions with supplier recommendations
   */
  async getProcurementSuggestions(
    menuPlanId: string,
    sppgId: string
  ): Promise<{
    suggestions: Array<{
      itemName: string
      suggestedQuantity: number
      unit: string
      preferredSupplier: {
        id: string
        name: string
        averageLeadTime: number
      } | null
      lastPurchasePrice: number
      averagePrice: number
    }>
  }> {
    const ingredients = await this.calculateRequiredIngredientsFromMenuPlan(menuPlanId, sppgId)

    const suggestions = await Promise.all(
      ingredients.map(async (ing) => {
        // Get inventory item with supplier info
        const item = await db.inventoryItem.findUnique({
          where: { id: ing.inventoryItemId },
          include: {
            preferredSupplier: {
              select: {
                id: true,
                supplierName: true,
                leadTimeHours: true,
              },
            },
          },
        })

        return {
          itemName: ing.itemName,
          suggestedQuantity: ing.requiredQuantity,
          unit: ing.unit,
          preferredSupplier: item?.preferredSupplier
            ? {
                id: item.preferredSupplier.id,
                name: item.preferredSupplier.supplierName,
                averageLeadTime: item.preferredSupplier.leadTimeHours || 0,
              }
            : null,
          lastPurchasePrice: item?.lastPrice || 0,
          averagePrice: item?.averagePrice || 0,
        }
      })
    )

    return { suggestions }
  }
}

// Export singleton instance
export const procurementMenuIntegrationService = new ProcurementMenuIntegrationService()
